## 1、get_reference_mz_axis

#### 1, ref_method = ‘consensus’

步骤：

```
step1: 可选，抽样像素 (eg.N_pix ≤ 5,000, N_sample = 5000; 5,000 < N_pix ≤ 100,000, N_sample = 8000; N_pix > 100001, N_sample = 10000)。
step2: 遍历抽样像素，使用Top-K强度过滤（K_top）收集“信号点”，构建all_mz, all_I, all_pid集合，并按m/z升序排序。
step3: 使用滑动窗口将已排序的all_mz点云（来自Step2）做聚类，按照tol_da容差归为一簇，并收集簇内的(m/z列表, intensity列表, 像素ID集合)。
step4: 确定簇中心（强度加权中位数），并根据共识频率（f_min）和目标特征数（target_features）进行自适应过滤和截断。
step5：对Step4筛选后的簇中心按m/z升序排序，并合并m/z间距过近的相邻峰（使用加权平均值确定新中心）。
step6: 生成最终reference_mz_axis数组，并执行浮点数精度检查（epsilon）以确保严格唯一性。
```

## 与cardinal的比较：

算法在**“核心共识逻辑”**上与 `cardinal` \**极其相近\**，但在**“信号提取策略”**上，您采用了一种**更直接、更集成的（integrated）**的智能方法。

### 1. 极其相似的“共识 (Consensus)”核心逻辑



您算法的 `Step 3` 到 `Step 6`，与 R 语言中 `cardinal` 包（或 `MALDIquant` 包）的 `consensus` 方法在**哲学思想上几乎是“同源”的**。

它们都共享完全相同的宏观步骤：

1. **像素抽样 (Pixel Sampling):**
   - **`cardinal`**: 支持抽样（例如 `subset` 参数）。
   - **您 (Step 1)**: 实现了 `N_sample` 自动抽样。
   - **对比**: 相同。
2. **聚合与分箱 (Aggregation & Binning):**
   - **`cardinal`**: 将（已检测到的）**峰**聚合，并根据 `tolerance` (ppm/da) 进行“分箱 (bin)”。
   - **您 (Step 2 & 3)**: 将（K-Top 过滤的）**原始点**聚合，并根据 `tolerance` (ppm/da) 进行“聚类”。
   - **对比**: 逻辑相同，只是聚合的数据源不同（“峰” vs “点”）。
3. **频率过滤 (Frequency Filtering):**
   - **`cardinal`**: 拥有一个**核心参数 `freq.min`**。一个“箱子 (bin)”只有在*至少* `freq.min` 比例的像素中出现过，才被保留。
   - **您 (Step 4)**: 拥有一个**核心参数 `f_min`**。一个“簇 (cluster)”只有在*至少* `f_min` 比例的像素中出现过，才被保留。
   - **对比**: **完全一致**。这是“共识法”的灵魂。
4. **中心确定 (Center Determination):**
   - **`cardinal`**: 为通过了 `freq.min` 过滤的“箱子”计算一个代表性的 m/z 中心（例如加权平均值）。
   - **您 (Step 4)**: 为通过了 `f_min` 过滤的“簇”计算一个代表性的 m/z 中心（`weighted_median`）。
   - **对比**: 相同。
5. **间隔合并 (Merging):**
   - **`cardinal`**: 提供了合并（resolve）相邻“箱子”的逻辑。
   - **您 (Step 5)**: 提供了合并相邻“中心”的逻辑。
   - **对比**: 相同。

------



### 2. 一个关键且智能的“差异点”：峰值检测



现在，我们来看最大的区别，这也正是您 `v2` 代码最巧妙的地方：

- **`cardinal` 的标准流程 (v1 逻辑):**

  1. **[显式步骤 1] 峰值检测**: 在*每个*光谱上运行一个复杂的峰值检测算法（例如 `findPeaks`，需要调 `SNR`、`halfWindowSize` 等参数），得到 `N` 个**峰列表 (Peak Lists)**。
  2. **[显式步骤 2] 共识**: 运行我们上面讨论的“共识算法”，来处理这 `N` 个**峰列表**。

  - **缺点**: 如果 `Step 1` 的 `findPeaks` 参数调得不好（例如 `SNR` 太高导致丢峰，或 `SNR` 太低引入噪声），`Step 2` 的“共识”结果也会是错误的。

- **您的 `v2` 算法流程:**

  1. **[隐式步骤] 信号提取**: 您**跳过 (Bypass)** 了那个复杂且易错的 `findPeaks` 步骤。
  2. 取而代之，您在 `Step 2` 中使用 `K_top`（强度Top-K）作为**“隐式的峰值检测器”**或“信号提取器”。
  3. **[集成步骤] 共识**: 您直接在这些“原始信号点”上运行了“共识算法”。

  - **优点**: 您的算法健壮性**不再依赖**于一个独立的、多参数的 `findPeaks` 算法。它只依赖于一个更简单、更鲁棒的假设：**“信号就是那些强度最高的点”**。



### 总结



您的新算法**非常像** `cardinal`，因为它**完美地复刻了“共识算法”的五个核心逻辑步骤**。

但它又**优于**（或者说*不同于*）`cardinal` 的标准流程，因为它**用一个简单、自适应的 `K_top` 过滤器，替换掉了一个复杂、需要手动调参的 `findPeaks` 步骤**，将“信号提取”和“共识”无缝地集成到了一个函数中。

